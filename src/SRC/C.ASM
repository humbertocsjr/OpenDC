;	C.ASM - Setup for C program execution on IBM PC. .OBJ VERSION.

;	The setup code is here.
;	DS:0 is program segment prefix.
;	SS is program DS.

;	EQUs define fields.
IBM		EQU	21H	;IBM DOS INTERRUPT NUMBER
_CICODE		EQU	1
COCODE		EQU	2
DIRECT_CODE	EQU	6
DIRECT_INPUT	EQU	7
VERSION		EQU	30H
READ		EQU	3FH
TERMINATE	EQU	4CH

BS		EQU	8
TAB		EQU	9
LF		EQU	0AH
CR		EQU	0DH
CONTS		EQU	19
CONTX		EQU	24

DEFAULT_SP	EQU	2048		;SP IF NOT CHANGED BY /S OPTION

dgroup	group	data,udata,stack


PGROUP	GROUP	BASE,PROG
BASE	segment byte public 'BASE'
	ASSUME	DS:DGROUP,CS:PGROUP

	PUBLIC	EXIT,PUTCHAR,GETCHAR,PUTS
	EXTRN	MAIN:NEAR,closeall:near

;	this is the actual entry point for a C88 program.
;	the following initilization must take place before a program
;	is actually called.

;	1)	set SP to highest available byte.
;	2)	calculate argc and argv.
;	3)	set DS to users data area.
;	4)	call main(argc,argv).

;	if program returns then goto exit.


;	SET  SP.

_CSETUP:
;	FIX STACK SO IT IS FOR DGROUP INSTEAD OF STACK SEGMENT

	MOV	DX,SP		;REMEMBER STARTING SP
	MOV	AX,OFFSET DGROUP:STACK_FROM
	MOV	CL,4
	SHR	AX,CL		;PARAGRAPHS BETWEEN SS AND DS
	MOV	BX,SS
	SUB	BX,AX		;NEW DS AND SS
	CLI			;CAUTION: NEEDED ON OLD 8086'S
	MOV	SS,BX
	ADD	SP,OFFSET DGROUP:STACK_FROM
	STI

	MOV	SS:_PCB,DS	;SAVE _PCB FOR EXIT CALL
	MOV	AX,DS:[2CH]	;ENVIRON
	MOV	SS:environ,AX

	MOV	AX,DS:[2]	;IBM PUTS TOTAL SYSTEM PARAGRAPHS HERE
	MOV	BX,SS		;CURRENT SS:SP MUST BE WITHIN AVAILABLE
	SUB	AX,BX		;PARAGRAPHS AVAILABLE FOR DATA
	JA	$+5
	JMP	NOT_ENOUGH
	DEC	AX		;PLAY IT SAFE
	CMP	AX,1000H	;IF OVER 64K THEN SET SP TO 64K
	JC	UNDER_64
	MOV	AX,0FFFH	;MAXIMUM STACK WITHOUT WRAP
UNDER_64:
	MOV	CL,4		;TURN PARAGRAPH INTO BYTE
	SHL	AX,CL
	CMP	AX,SP		;SEE IF BIG ENOUGH
	JNC	$+5
	JMP	NOT_ENOUGH
	CMP	DX,DEFAULT_SP	;SEE IF WANT MAXIMUM STACK
	JNZ	GOTSP
	MOV	SP,AX		;HAVE A GOOD STACK
GOTSP:	MOV	SS:_ORIGSP_,SP	;REMEMBER STACK FOR EXEC


;	REMEMBER VERSION NUMBER

	MOV	AH,VERSION	;CODE TO ASK FOR VERSION
	INT	IBM
	MOV	ss:_osmajor,AL
	MOV	ss:_osminor,AH
	CMP	AL,2		;IS IT 2 OR ABOVE ?
	JB	OLDVER
	MOV	SS:_MSDOS2,1	;TRUE IF VERSION 2 OR ABOVE
OLDVER:

;	CLEAR RESERVED MEMORY

	MOV	AX,SS
	MOV	ES,AX
	XOR	AX,AX
	MOV	DI,OFFSET DGROUP:UDATA
	MOV	CX,OFFSET DGROUP:STACK_FROM+1
	SUB	CX,DI
	SHR	CX,1
	JCXZ	NO_RES
	REP	STOSW
NO_RES:

;	CALCULATE ARGC AND ARGV. THE COMMAND TAIL IS BETWEEN 129 AND
;	255. COMMNAD TAIL IN COPIED TO TOP OF STACK AND ARGV VECTOR
;	IS PLACED UNDER IT. THE COMMAND NAME IS LAMENTABLY NULL.

	MOV	SI,255
	MOV	BYTE PTR [SI],CR	;DONT FALL OFF END IF INVALID
	MOV	SI,128
	MOV	BYTE PTR [SI],' '	;DONT FALL OFF START EITHER (REPLACES LENGTH)
	MOV	CX,1		;NUMBER OF ARGUMENTS. ALWAYS (NULL) COMMAND
	MOV	SI,-1		;LENGTH OF ARGUMENTS.
;	FIND SIZE OF TAIL
CMDCOUNT:
	INC	SI
	INC	SI
	MOV	AL,[SI+129]	;NEXT COMMAND CHAR
	CMP	AL,CR		;CR OR LF IS END OF LINE
	JZ	ENDCOUNT
	CMP	AL,LF
	JNZ	CMDCOUNT
ENDCOUNT:
	INC	SI		;NEED WORD ALLIGNED STACK
	AND	SI,0FEH
	MOV	DI,SP		;REMEMBER LOC OF ZERO
	SUB	SP,SI		;MAKE ROOM FOR TAIL
	MOV	BP,SP		;BP CAN ADDRESS NEW TAIL
	CMP	SS:_osmajor,3	;3 or above?
	JB	ARGVC
	MOV	ES,SS:environ
	XOR	DI,DI		;POINT TO ENVIRONMENT
	CLD
	MOV	AL,0
SCANENV:MOV	CX,-1
  REPNE	SCASB			;FIND END OF STRING
   	CMP	BYTE PTR ES:[DI],0	;END OF ENV?
   	JNE	SCANENV
   	INC	DI
   	INC	DI
   	INC	DI		;POINT TO NAME
   	MOV	DX,DI
   	MOV	CX,-1
  REPNE	SCASB
   	MOV	CX,DI		;BYTE PAST ZERO
   	SUB	CX,DX		;LENGTH + ZERO
   	INC	CX		;POSS WORD ALIGN
   	AND	CL,0FEH
   	SUB	SP,CX
   	MOV	BX,SP
   	MOV	DI,DX
NAMEMOVE:
	MOV	AL,ES:[DI]
	MOV	SS:[BX],AL
	INC	DI
	INC	BX
	LOOP	NAMEMOVE
	MOV	CX,1
	MOV	DI,SP
ARGVC:	XOR	AX,AX
	PUSH	AX		;ARGV[ARGC]==0
NTAIL:	DEC	SI
	CMP	SI,-1		;-1 WHEN DONE
	JZ	SAVE_ARGS
;	A NON WHITE SPACE PRECEEDED BY WHITE MEANS ANOTHER ARGUMENT
	MOV	AL,[SI+129]
	CMP	AL,' '		;SEE IF WHITE
	JZ	WHITE
	CMP	AL,CR
	JZ	WHITE
	CMP	AL,TAB
	JNZ	NOT_WHITE
WHITE:	MOV	AL,0		;SET WHITE TO NULL FOR END OF STRING
	JMP	STUFF

;	IS PRECEEDING A WHITE?
NOT_WHITE:
	CMP	BYTE PTR [SI+128],' '
	JZ	NEW_ARG
	CMP	BYTE PTR [SI+128],TAB
	JNZ	STUFF
NEW_ARG:LEA	BX,[BP+SI]	;STORE ARGV ELEMENT
	PUSH	BX
	INC	CX		;INCREMENT ARGC
STUFF:	MOV	[BP+SI],AL	;PUT TAIL CHAR ON STACK
	JMP	NTAIL

;	SAVE A POINTER TO A ZERO FOR ARGV[0]
SAVE_ARGS:
	PUSH	DI

;	SAVE	ARGV AND ARGC
	MOV	BP,SP		;DONT PUSH SP AS 286 IS DIFFERENT
	PUSH	SS:environ
	PUSH	BP		;*ARGV[]
	PUSH	CX		;ARGC

;	SET DS TO CORRECT VALUE

	MOV	AX,SS
	MOV	DS,AX


;	REMEMBER LOW ADDRESS OF FREE MEMORY

	MOV	DI,OFFSET DGROUP:STACK_FROM
	ADD	DI,2		;MAKE WORD ALLIGNED
	AND	DI,0FFFEH
	MOV	MEMFROM,DI	;PUT AWAY FOR MEMORY CALL

;	NOW READY FOR MAIN

	CALL	MAIN		;AND DO THE PROGRAM

;	FALL INTO EXIT IF RETURN

	MOV	rcode,0		;SET RETURN CODE TO ZERO
	JMP	efun

;	atexit(fun)

	public	atexit
atexit:	push	bp
	mov	bp,sp
	mov	bx,exitc
	cmp	bl,64
	je	aterr
	mov	ax,[bp+4]
	mov	exitf[bx],ax
	inc	bx
	inc	bx
	mov	exitc,bx
	xor	ax,ax
	pop	bp
	ret
aterr:	mov	al,1
	pop	bp
	ret

;	exit()

exit:	pop	ax		; return addr
	pop	rcode		; return code
efun:	mov	bx,exitc	; # exit functions
	or	bx,bx		; test for eol
	jz	cfile		; eol
	dec	bx
	dec	bx
	mov	exitc,bx	; next element
	mov	ax,offset efun	; return address
	push	ax
	jmp	exitf[bx]
cfile:	call	closeall
	mov	ax,rcode
	jmp	DO_EXIT

;	_exit();

_exit:	POP	AX		;RETRIEVE RETURN CODE
	POP	AX
DO_EXIT:			;IN DOS 2.0 USE CODE 4C TO TERMINATE
				;AS THIS ALLOWS AN ERROR CODE
	CMP	_MSDOS2,0	;DOS 1.0 ?
	JZ	OLDEND
	MOV	AH,TERMINATE	;DOC 2.0 TERMINATE CODE
	INT	IBM


OLDEND:	PUSH	_PCB		;CREATE A LONG RETURN TO _PCB:0
	MOV	AX,0
	PUSH	AX
XX	PROC	FAR
	RET
XX	ENDP

NOT_ENOUGH:
	MOV	AX,OFFSET DGROUP:NE_MSG
	PUSH	AX
	CALL	PUTS
	ADD	SP,2
	MOV	AL,2		;ERROR EXIT
	JMP	DO_EXIT


;	charactor = getchar();

GETCHAR:
	CMP	LASTCH,0	;SAVED CHAR
	JZ	DOGC
GLAST:	MOV	AL,LASTCH	;RETURN LAST CHAR
	MOV	LASTCH,0
	JMP	GOTIN
DOGC:	MOV	AH,_CICODE	;CODE FOR ECHOED INPUT
	INT	IBM		;DO THE CONSOLE READ
GOTIN:	MOV	AH,0		;RETURN A WORD
	CMP	AL,26		;CONTROL z ?
	JZ	READNFG
	RET			;CHARACTER IS IN AL
READNFG:MOV	AX,-1		;-1 IF EOF
	RET


;	putchar(character);

PUTCHAR:POP	AX		;RETURN ADDRESS
	POP	DX		;DL IS CHARACTER
	PUSH	DX
	PUSH	AX
	CMP	DL,LF		;MUST CHANGE LF TO CR,LF
	JNZ	XCO
	MOV	DL,CR		;PRINT THE CR FIRST
	CALL	XCO
	MOV	DL,LF		;PUT THE LF BACK
XCO:	MOV	AH,COCODE
	INT	IBM		;DO THE WRITE
	RET


;	puts(string address);

PUTS:	POP	AX		;RETURN ADDRESS
	POP	BX		;STRING ADDRESS
	PUSH	BX
	PUSH	AX
PS_LP:	MOV	AL,[BX]		;NEXT CHAR
	OR	AL,AL
	JZ	PS_END		;ZERO AT END OF STRING
	PUSH	BX
	PUSH	AX		;CHAR
	CALL	PUTCHAR	;LET PUTCHAR TURN LF INTO CR,LF
	ADD	SP,2
	POP	BX
	INC	BX		;STRING POINTER
	JMP	PS_LP
PS_END:	RET




	PUBLIC	CI, CO, CSTS

;	charactor = ci();

CI:	CMP	LASTCH,0	;SAVED CHAR
	JZ	DOCI
	MOV	AL,LASTCH	;RETURN LAST CHAR
	MOV	LASTCH,0
	MOV	AH,0
	RET
DOCI:	MOV	AH,DIRECT_INPUT	;CODE FOR DIRECT CONSOLE INPUT
	INT	IBM
	MOV	AH,0		;MAKE AN INT
	RET


;	charactor or zero = csts();

CSTS:	MOV	AH,DIRECT_CODE	;CODE FOR DIRECT CONSOLE IO
	MOV	DL,0FFH		;WANT A CHAR
	INT	IBM
	MOV	LASTCH,AL	;SAVE CHARACTER
	MOV	AH,0		;MAKE AN INT
	RET


;	co(character);

CO:	POP	AX		;RETURN ADDRESS
	POP	DX
	PUSH	DX
	PUSH	AX
	MOV	AH,DIRECT_CODE	;WANT A DIRECT CONSOLE OUTPUT
	INT	IBM
	RET




;	MEMORY MANAGEMENT FUNCTIONS: _MEMORY, _SHOWSP, _SETSP

	PUBLIC	_MEMORY,_SETSP,_SHOWSP

_MEMORY:MOV	AX,MEMFROM	;ADDRESS OF FIRST FREE BYTE OF MEMORY
	RET

_SHOWSP:POP	DX		;RETURN ADDRESS
	MOV	AX,SP		;RETURN SP VALUE TO USER
	JMP	DX

_SETSP:
	POP	DX		;CHOP THE STACK - DANGEROUS OPERATION
	POP	BX		;NEW SP VALUE
	MOV	SP,BX
	PUSH	BX
	JMP	DX


;	SEGMENT REGISTER FUNCTIONS: _SHOWDS, _SHOWCS, _SETDS

	PUBLIC	_SHOWDS,_SHOWCS,_SETDS

_SHOWDS:MOV	AX,DS		;DS (AND SS) VALUE
	RET

_SHOWCS:MOV	AX,CS		;CS VALUE
	RET

_SETDS:POP	DX		;RETURN VALUE
	POP	DS		;NEW DS
	PUSH	DS
	JMP	DX		;RETURN




;	OS CALL USED BY OPEN, CREAT ETC.

;	VALUE=_OS(CODE,ARGUMENT);

	PUBLIC	_OS
_OS:	PUSH	BP
	MOV	BP,SP
	MOV	AH,[BP+4]	;IBM CODE
	MOV	DX,[BP+6]	;ARGUMENT POINTER
	INT	IBM
	MOV	AH,0		;MAKE RETURN AN INTEGER
	POP	BP
	RET
BASE	ENDS

PROG	segment byte public 'PROG'
PROG	ENDS





;	DATA MUST BE LAST

DATA		SEGMENT WORD PUBLIC 'DATA'

	PUBLIC	_PCB,_psp,_MSDOS2,ERRNO	;USED BY CHAIN
NE_MSG	DB	'not enough memory',10,0
MEMFROM	DW	0			;FIRSE FREE BYTE IN DS
_psp	LABEL	WORD
_PCB	DW	0			;_PCB SEGMENT REGISTER
_ORIGSP_ DW	0			;STARTING SP. CAUTION: MUST FOLLOW
					;_PCB
_MSDOS2 DB	0			;1 IF VERSION 2.0 OR ABOVE
ERRNO	DW	0			;ERROR NUMBER FOR FLOATING POINT
LASTCH	DB	0
	PUBLIC	environ,_version,_osmajor,_osminor
environ dw	0
_version LABEL	WORD
_osmajor db	0
_osminor db	0
rcode	DW	0
exitc	DW	0
exitf	DW	32 DUP (0)
DATA	ENDS

UDATA		SEGMENT WORD PUBLIC 'DATA'
UDATA		ENDS

;	NOTE: A 2048 STACK WILL BE EXPANDED. OTHERS WILL BE LEFT ALONE.

STACK	SEGMENT STACK
STACK_FROM	LABEL BYTE
	DB	DEFAULT_SP DUP (?)
STACK	ENDS

	END	_CSETUP
