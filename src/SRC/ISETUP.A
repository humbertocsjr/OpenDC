;	ISETUP.A - Setup for C program execution on IBM PC.

;	jumped to by first instruction to do C initilization.
;	DS:0 is program segment prefix.
;	SS is program DS.
;	SS:0 is size of C initilized memory.
;	SS:2 is size of uninitilized memory.

;	EQUs define fields.

	include	"CONFIG.H"

IBM		EQU	21H	;IBM DOS INTERRUPT NUMBER
CI_CODE		EQU	1
CO_CODE		EQU	2
DIRECT_CODE	EQU	6
DIRECT_INPUT	EQU	7
VERSION		EQU	30H
READ		EQU	3FH
SETBLK		EQU	4AH
TERMINATE	EQU	4CH

BS		EQU	8
TAB		EQU	9
LF		EQU	0AH
CR		EQU	0DH
CONTS		EQU	19
CONTX		EQU	24

	DSEG
	PUBLIC	_PCB_,_psp_,_MSDOS2_	;USED BY CHAIN
NE_MSG	DB	'not enough memory',10
MEMFROM	DW	0		;FIRSE FREE BYTE IN DS
_psp_:
_PCB_	DW	0		;_PCB_ SEGMENT REGISTER
_ORIGSP_ DW	0		;STARTING SP. CAUTION: MUST FOLLOW
				;_PCB_
_MSDOS2_ DB	0		;1 IF VERSION 2.0 OR ABOVE
VERS	DB	0		;VERSION NUMBER
LASTCH	DB	0
CURCH	DB	0

rcode	RW	1
exitc	RW	1

	PUBLIC	environ_,_version_,_osmajor_,_osminor_
environ_ dw	0
_version_:
_osmajor_ db	0
_osminor_ db	0
	PUBLIC	ERRNO_
ERRNO_	RW	1		;ERROR NUMBER

	if	MODEL == 0

exitf	RW	32

	CSEG

	PUBLIC	_CSETUP,exit_,_exit_,PUTCHAR_,GETCHAR_,PUTS_,MAIN_

;	this is the actual entry point for a C88 program.
;	the following initilization must take place before a program
;	is actually called.

;	1)	set SP to highest available byte.
;	2)	set uninitilized storage to zero.
;	3)	calculate argc and argv.
;	4)	set DS to users data area.
;	5)	call main(argc,argv).

;	if program returns then goto exit.


;	SET  SP.

_CSETUP:
	MOV	SS:_PCB_,DS	;SAVE _PCB_ FOR EXIT CALL
	MOV	AX,[2CH]	;ENVIRON
	MOV	SS:environ_,AX
	MOV	AX,[2]		;IBM PUTS TOTAL SYSTEM PARAGRAPHS HERE
	MOV	BX,SS		;CURRENT SS:SP MUST BE WITHIN AVAILABLE
	SUB	AX,BX		;PARAGRAPHS AVAILABLE FOR DATA
	JBE	NOT_ENOUGH
	DEC	AX		;PLAY IT SAFE
	CMP	AX,1000H	;IF OVER 64K THEN SET SP TO 64K
	JC	UNDER_64
	MOV	AX,0FFFH	;MAXIMUM STACK WITHOUT WRAP
UNDER_64:
	MOV	CL,4		;TURN PARAGRAPH INTO BYTE
	SHL	AX,CL
	CMP	AX,SP		;SEE IF BIG ENOUGH
	JC	NOT_ENOUGH
	MOV	BX,SS:[0]	;IF SP IS INIT DATA+RESDATA+127 THEN MAKE MAX.
	ADD	BX,SS:[2]
	ADD	BX,127
	CMP	SP,BX		;WANT MAXIMUM ?
	JNZ	HAVE_SP		;NO, MUST HAVE HAS A -Snn OPTION OF BIND
	MOV	SP,AX		;HAVE A GOOD STACK
HAVE_SP:MOV	SS:_ORIGSP_,SP	;REMEMBER STACK FOR EXEC


;	REMEMBER VERSION NUMBER

	MOV	AH,VERSION	;CODE TO ASK FOR VERSION
	INT	IBM
	MOV	ss:_osmajor_,AL
	MOV	ss:_osminor_,AH
	CMP	AL,2		;IS IT 2 OR ABOVE ?
	JB	OLDVER
	MOV	SS:_MSDOS2_,1	;TRUE IF VERSION 2 OR ABOVE
	MOV	SS:VERS,AL	;REMEMBER VERSION FOR ARGV[0]
OLDVER:

;	CALCULATE ARGC AND ARGV. THE COMMAND TAIL IS BETWEEN 129 AND
;	255. COMMNAD TAIL IN COPIED TO TOP OF STACK AND ARGV VECTOR
;	IS PLACED UNDER IT. THE COMMAND NAME IS LAMENTABLY NULL.
MOV	BYTE [255],CR	;DONT FALL OFF END IF INVALID
	MOV	BYTE [128],' '	;DONT FALL OFF START EITHER (REPLACES LENGTH)
	MOV	CX,1		;NUMBER OF ARGUMENTS. ALWAYS (NULL) COMMAND
	MOV	SI,-1		;LENGTH OF ARGUMENTS.
;	FIND SIZE OF TAIL
CMD_COUNT:
	INC	SI
	MOV	AL,[SI+129]	;NEXT COMMAND CHAR
	CMP	AL,CR		;CR OR LF IS END OF LINE
	JZ	END_COUNT
	CMP	AL,LF
	JNZ	CMD_COUNT
END_COUNT:
	INC	SI
	INC	SI
	AND	SI,0FEH		;NEED WORD ALLIGNED STACK
	MOV	DI,SP		;REMEMBER LOC OF ZERO
	SUB	SP,SI		;MAKE ROOM FOR TAIL
	MOV	BP,SP		;BP CAN ADDRESS NEW TAIL
	CMP	SS:_osmajor_,3	;3 or above?
	JB	ARGVC
	MOV	ES,SS:environ_
	XOR	DI,DI		;POINT TO ENVIRONMENT
	CLD
	MOV	AL,0
SCANENV:MOV	CX,-1
  REPNE	SCASB			;FIND END OF STRING
   	CMP	BYTE ES:[DI],0	;END OF ENV?
   	JNE	SCANENV
   	INC	DI
   	INC	DI
   	INC	DI		;POINT TO NAME
   	MOV	DX,DI
   	MOV	CX,-1
  REPNE	SCASB
   	MOV	CX,DI		;BYTE PAST ZERO
   	SUB	CX,DX		;LENGTH + ZERO
   	INC	CX		;POSS WORD ALIGN
   	AND	CL,0FEH
   	SUB	SP,CX
   	MOV	BX,SP
   	MOV	DI,DX
NAMEMOVE:
	MOV	AL,ES:[DI]
	MOV	SS:[BX],AL
	INC	DI
	INC	BX
	LOOP	NAMEMOVE
	MOV	CX,1
	MOV	DI,SP
ARGVC:	XOR	AX,AX
	PUSH	AX		;ARGV[ARGC]==0
NTAIL:	DEC	SI
	CMP	SI,-1		;-1 WHEN DONE
	JZ	SAVE_ARGS
;	A NON WHITE SPACE PRECEEDED BY WHITE MEANS ANOTHER ARGUMENT
	MOV	AL,[SI+129]
	CMP	AL,' '		;SEE IF WHITE
	JZ	WHITE
	CMP	AL,CR
	JZ	WHITE
	CMP	AL,TAB
	JNZ	NOT_WHITE
WHITE:	MOV	AL,0		;SET WHITE TO NULL FOR END OF STRING
	JMP	STUFF

;	IS PRECEEDING A WHITE?
NOT_WHITE:
	CMP	BYTE [SI+128],' '
	JZ	NEW_ARG
	CMP	BYTE [SI+128],TAB
	JNZ	STUFF
NEW_ARG:LEA	BX,[BP+SI]	;STORE ARGV ELEMENT
	PUSH	BX
	INC	CX		;INCREMENT ARGC
STUFF:	MOV	[BP+SI],AL	;PUT TAIL CHAR ON STACK
	JMP	NTAIL

;	SAVE A POINTER TO A NAME OR ZERO FOR ARGV[0]
SAVE_ARGS:
	PUSH	DI

;	SAVE	ARGV AND ARGC
	MOV	BP,SP		;DONT PUSH SP AS 286 IS DIFFERENT
	PUSH	WORD SS:environ_
	PUSH	BP		;*ARGV[]
	PUSH	CX		;ARGC

;	SET DS TO CORRECT VALUE

	MOV	AX,SS
	MOV	DS,AX

;	INITILIZE UNINITILIZED MEMORY TO ZERO

	MOV	DI,[0]		;LENGTH OF INITILIZED MEMORY IS HERE
	MOV	CX,[2]		;LENGTH OF UNINITILIZED IS HERE
	MOV	ES,AX		;ES=DS
	MOV	AL,0		;THE ZERO
	CLD
REP	STOSB

;	REMEMBER LOW ADDRESS OF FREE MEMORY

	ADD	DI,2		;MAKE WORD ALLIGNED
	AND	DI,0FFFEH
	MOV	MEMFROM,DI	;PUT AWAY FOR MEMORY CALL

;	NOW READY FOR MAIN

	CALL	MAIN_		;AND DO THE PROGRAM

;	FALL INTO EXIT IF RETURN

	MOV	rcode,0		;SET RETURN CODE TO ZERO
	JMP	efun

;	atexit(fun)

	public	atexit_
atexit_:push	bp
	mov	bp,sp
	mov	bx,exitc
	cmp	bl,64
	je	aterr
	mov	ax,[bp+4]
	mov	exitf[bx],ax
	inc	bx
	inc	bx
	mov	exitc,bx
	xor	ax,ax
	pop	bp
	ret
aterr:	mov	al,1
	pop	bp
	ret

;	exit()

exit_:	pop	ax		; return addr
	pop	rcode		; return code
efun:	mov	bx,exitc	; # exit functions
	or	bx,bx		; test for eol
	jz	cfile		; eol
	dec	bx
	dec	bx
	mov	exitc,bx	; next element
	mov	ax,offset efun	; return address
	push	ax
	jmp	exitf[bx]
	public	closeall_
cfile:	call	closeall_
	mov	ax,rcode
	jmp	DO_EXIT

;	_exit();

_exit_:	POP	AX		;RETRIEVE RETURN CODE
	POP	AX
DO_EXIT:			;IN DOS 2.0 USE CODE 4C TO TERMINATE
				;AS THIS ALLOWS AN ERROR CODE
	CMP	_MSDOS2_,0	;DOS 1.0 ?
	JZ	OLDEND
	MOV	AH,TERMINATE	;DOC 2.0 TERMINATE CODE
	INT	IBM


OLDEND:	PUSH	_PCB_		;CREATE A LONG RETURN TO _PCB_:0
	MOV	AX,0
	PUSH	AX
	LRET

NOT_ENOUGH:
	MOV	AX,&NE_MSG
	PUSH	AX
	CALL	PUTS_
	ADD	SP,2
	MOV	AL,2		;ERROR EXIT
	JMP	DO_EXIT


;	charactor = getchar();

GETCHAR_:
	CMP	LASTCH,0	;SAVED CHAR
	JZ	DOGC
GLAST:	MOV	AL,LASTCH	;RETURN LAST CHAR
	MOV	LASTCH,0
	JMP	GOTIN
DOGC:	MOV	AH,CI_CODE	;CODE FOR ECHOED INPUT
	INT	IBM		;DO THE CONSOLE READ
GOTIN:	MOV	AH,0		;RETURN A WORD
	CMP	AL,26		;CONTROL z ?
	JZ	READNFG
	RET			;CHARACTER IS IN AL
READNFG:MOV	AX,-1		;-1 IF EOF
	RET


;	putchar(character);

PUTCHAR_:POP	AX		;RETURN ADDRESS
	POP	DX		;DL IS CHARACTER
	PUSH	DX
	PUSH	AX
	CMP	DL,LF		;MUST CHANGE LF TO CR,LF
	JNZ	XCO
PS_END:	MOV	DL,CR		;PRINT THE CR FIRST
	CALL	XCO
	MOV	DL,LF		;PUT THE LF BACK
XCO:	MOV	AH,CO_CODE
	INT	IBM		;DO THE WRITE
	MOV	AH,CO_CODE
	RET


;	puts(string address);

PUTS_:	POP	AX		;RETURN ADDRESS
	POP	BX		;STRING ADDRESS
	PUSH	BX
	PUSH	AX
PS_LP:	MOV	AL,[BX]		;NEXT CHAR
	OR	AL,AL
	JZ	PS_END		;\n AT END OF STRING
	PUSH	BX
	PUSH	AX		;CHAR
	CALL	PUTCHAR_	;LET PUTCHAR TURN LF INTO CR,LF
	ADD	SP,2
	POP	BX
	INC	BX		;STRING POINTER
	JMP	PS_LP





	PUBLIC	CI_, CO_, CSTS_

;	charactor = ci();

CI_:	CMP	LASTCH,0	;SAVED CHAR
	JZ	DOCI
	MOV	AL,LASTCH	;RETURN LAST CHAR
	MOV	LASTCH,0
	MOV	AH,0
	RET
DOCI:	MOV	AH,DIRECT_INPUT	;CODE FOR DIRECT CONSOLE INPUT
	INT	IBM
	MOV	AH,0		;MAKE AN INT
	RET


;	charactor or zero = csts();

CSTS_:	MOV	AH,DIRECT_CODE	;CODE FOR DIRECT CONSOLE IO
	MOV	DL,0FFH		;WANT A CHAR
	INT	IBM
	MOV	LASTCH,AL	;SAVE CHARACTER
	MOV	AH,0		;MAKE AN INT
	RET


;	co(character);

CO_:	POP	AX		;RETURN ADDRESS
	POP	DX
	PUSH	DX
	PUSH	AX
	MOV	AH,DIRECT_CODE	;WANT A DIRECT CONSOLE OUTPUT
	INT	IBM
	RET




;	MEMORY MANAGEMENT FUNCTIONS: _MEMORY, _SHOWSP, _SETSP

	PUBLIC	_MEMORY_,_SETSP_,_SHOWSP_

_MEMORY_:MOV	AX,MEMFROM	;ADDRESS OF FIRST FREE BYTE OF MEMORY
	RET

_SHOWSP_:POP	DX		;RETURN ADDRESS
	MOV	AX,SP		;RETURN SP VALUE TO USER
	JMP	DX

_SETSP_:
	POP	DX		;CHOP THE STACK - DANGEROUS OPERATION
	POP	BX		;NEW SP VALUE
	CMP	BP,SP		;ANY LOCALS
	JNZ	NOC
	MOV	BP,BX		;MUST MOVE THE BP TOO
NOC:	MOV	SP,BX
	PUSH	BX
	JMP	DX


;	SEGMENT REGISTER FUNCTIONS: _SHOWDS, _SHOWCS, _SETDS

	PUBLIC	_SHOWDS_,_SHOWCS_,_SETDS_

_SHOWDS_:MOV	AX,DS		;DS (AND SS) VALUE
	RET

_SHOWCS_:MOV	AX,CS		;CS VALUE
	RET

_SETDS_:POP	DX		;RETURN VALUE
	POP	DS		;NEW DS
	PUSH	DS
	JMP	DX		;RETURN




;	OS CALL USED BY OPEN, CREAT ETC.

;	VALUE=_OS(CODE,ARGUMENT);

	PUBLIC	_OS_
_OS_:	PUSH	BP
	MOV	BP,SP
	MOV	AH,[BP+4]	;IBM CODE
	MOV	DX,[BP+6]	;ARGUMENT POINTER
	INT	IBM
	MOV	AH,0		;MAKE RETURN AN INTEGER
	POP	BP
	RET

	else

	DSEG

exitf	RW	64

	CSEG
;	LARGE CASE SETUP

	PUBLIC	_CSETUP,_exit_,exit_,PUTCHAR_,GETCHAR_,PUTS_,MAIN_

;	this is the actual entry point for a C88 program.
;	the following INITIALization must take place before a program
;	is actually called.

;	1)	set SP to highest available byte.
;	2)	set unINITIALized storage to zero.
;	3)	calculate argc and argv.
;	4)	set DS to users data area.
;	5)	call main(argc,argv).

;	if program returns then goto exit.


;	SET  SP.

_CSETUP:
	MOV	SS:_PCB_,DS	;SAVE _PCB_ FOR EXIT CALL
	MOV	AX,[2CH]	;ENVIRON
	MOV	SS:environ_,AX
	MOV	AX,SS		;CALCULATE SS LOCATION
	MOV	BX,SS:[0]	;INIT MEMORY
	ADD	BX,15
	MOV	CL,4
	SHR	BX,CL		;DS PARAGRAPHS
	ADD	BX,SS:[2]	;NUMBER OS ZERO SEGMENTS
	ADD	AX,BX		;NEW SS
	INC	AX
	MOV	BX,[2]		;IBM PUTS TOTAL SYSTEM PARAGRAPHS HERE
	CMP	AX,BX		;SEE IF FITS

	JAE	NOT_ENOUGH
	SUB	BX,AX		;NUMBER OF PARAS FOR STACK
	MOV	DX,SS:[4]	;DESIRED STACK SIZE
	SHR	DX,CL		;PARAS WANTED
	CMP	BX,DX		;HAVE ENOUGH?
	MOV	DX,SS:[4]	;DESIRED STACK SIZE
	JAE	SET_STACK
	SHL	BX,CL		;ROOM LEFT
	MOV	DX,BX

SET_STACK:
	PUSH	SS		;SET UP THE REAL STACK
	POP	ES		; ES IS LEFT TO POINT AT THE DATA SEGEMENT
	CLI
	MOV	SS,AX
	MOV	SP,DX
	STI

;	CHOP MEMORY ALLOCATION FOR BOTH MALLOC AND EXEC

	PUSH	ES
	MOV	CL,4
	SHR	DX,CL		;DX IS PARAS OF STACK TOP
	ADD	DX,AX		;DXBX IS MAX PARAGRAPH USED
	MOV	BX,DX
	INC	BX
	SUB	BX,ES:_PCB_	;PARAS NEED TO KEEP
	MOV	ES,ES:_PCB_
	MOV	AH,SETBLK	;REDUCE MEMORY ALLOCATED
	INT	IBM
	POP	ES

;	REMEMBER VERSION NUMBER

	PUSH	ES
	MOV	AH,VERSION	;CODE TO ASK FOR VERSION
	INT	IBM
	POP	ES
	MOV	es:_osmajor_,AL
	MOV	es:_osminor_,AH
	CMP	AL,2		;IS IT 2 OR ABOVE ?
	JB	OLDVER
	MOV	ES:_MSDOS2_,1	;TRUE IF VERSION 2 OR ABOVE
	MOV	ES:VERS,AL	;REMEMBER VERSION FOR ARGV[0]
OLDVER:

;	CALCULATE ARGC AND ARGV. THE COMMAND TAIL IS BETWEEN 129 AND
;	255. COMMNAD TAIL IN COPIED TO TOP OF STACK AND ARGV VECTOR
;	IS PLACED UNDER IT. THE COMMAND NAME IS LAMENTABLY NULL.

	MOV	BYTE [255],CR	;DONT FALL OFF END IF INVALID
	MOV	BYTE [128],' '	;DONT FALL OFF START EITHER (REPLACES LENGTH)
	MOV	CX,1		;NUMBER OF ARGUMENTS. ALWAYS (NULL) COMMAND
	MOV	SI,-1		;LENGTH OF ARGUMENTS.
;	FIND SIZE OF TAIL
CMD_COUNT:
	INC	SI
	MOV	AL,[SI+129]	;NEXT COMMAND CHAR
	CMP	AL,CR		;CR OR LF IS END OF LINE
	JZ	END_COUNT
	CMP	AL,LF
	JNZ	CMD_COUNT
END_COUNT:
	INC	SI
	INC	SI
	AND	SI,0FEH		;NEED WORD ALLIGNED STACK
	MOV	DI,SP		;REMEMBER LOC OF ZERO
	SUB	SP,SI		;MAKE ROOM FOR TAIL
	MOV	BP,SP		;BP CAN ADDRESS NEW TAIL
	CMP	ES:_osmajor_,3	;3 or above?
	JB	ARGVC
	MOV	DX,ES
	MOV	ES,ES:environ_
	XOR	DI,DI		;POINT TO ENVIRONMENT
	CLD
	MOV	AL,0
SCANENV:MOV	CX,-1
  REPNE	SCASB			;FIND END OF STRING
   	CMP	BYTE ES:[DI],0	;END OF ENV?
   	JNE	SCANENV
   	INC	DI
   	INC	DI
   	INC	DI		;POINT TO NAME
   	MOV	BX,DI
   	MOV	CX,-1
  REPNE	SCASB
   	MOV	CX,DI		;BYTE PAST ZERO
   	SUB	CX,BX		;LENGTH + ZERO
   	INC	CX		;POSS WORD ALIGN
   	AND	CL,0FEH
   	SUB	SP,CX
   	MOV	DI,BX
   	MOV	BX,SP
NAMEMOVE:
	MOV	AL,ES:[DI]
	MOV	SS:[BX],AL
	INC	DI
	INC	BX
	LOOP	NAMEMOVE
	MOV	CX,1
	MOV	DI,SP
	MOV	ES,DX
ARGVC:	XOR	AX,AX
	PUSH	AX
	PUSH	AX
NTAIL:	DEC	SI
	CMP	SI,-1		;-1 WHEN DONE
	JZ	SAVE_ARGS
;	A NON WHITE SPACE PRECEEDED BY WHITE MEANS ANOTHER ARGUMENT
	MOV	AL,[SI+129]
	CMP	AL,' '		;SEE IF WHITE
	JZ	WHITE
	CMP	AL,CR
	JZ	WHITE
	CMP	AL,TAB
	JNZ	NOT_WHITE
WHITE:	MOV	AL,0		;SET WHITE TO NULL FOR END OF STRING
	JMP	STUFF

;	IS PRECEEDING A WHITE?
NOT_WHITE:
	CMP	BYTE [SI+128],' '
	JZ	NEW_ARG
	CMP	BYTE [SI+128],TAB
	JNZ	STUFF
NEW_ARG:LEA	BX,[BP+SI]	;STORE ARGV ELEMENT
	PUSH	SS
	PUSH	BX
	INC	CX		;INCREMENT ARGC
STUFF:	MOV	[BP+SI],AL	;PUT TAIL CHAR ON STACK
	JMP	NTAIL

;	SAVE A POINTER TO NAME OR A ZERO FOR ARGV[0]
SAVE_ARGS:
	PUSH	SS
	PUSH	DI

;	SAVE	ARGV AND ARGC
	MOV	BP,SP		;DONT PUSH SP AS 286 IS DIFFERENT

	PUSH	WORD ES:environ_
	XOR	AX,AX
	PUSH	AX
	PUSH	SS
	PUSH	BP		;*ARGV[]
	PUSH	CX		;ARGC

;	SET DS TO CORRECT VALUE

	MOV	AX,ES
	MOV	DS,AX

;	INITIALIZE UNINITIALIZED MEMORY TO ZERO

	MOV	DX,[0]		;SIZE OF INITIALIZED IN BYTES
	MOV	BX,[2]		;NUMBER OF PARAGRAPHS TO ZERO
	XOR	AX,AX
	CLD
ZERO_MEM:
	MOV	DI,DX
	MOV	CX,8		;DO ONE PARA AT A TIME
REP	STOSW
	MOV	DI,ES		;INCREMENT ES
	INC	DI
	MOV	ES,DI
	DEC	BX
	JNZ	ZERO_MEM


;	NOW READY FOR MAIN

	LCALL	MAIN_		;AND DO THE PROGRAM

;	FALL INTO EXIT IF RETURN

	MOV	rcode,0		;SET RETURN CODE TO ZERO
	JMP	efun

;	atexit(fun)

	public	atexit_
atexit_:push	bp
	mov	bp,sp
	mov	bx,exitc
	cmp	bl,128
	je	aterr
	mov	ax,[bp+6]
	mov	dx,[bp+8]
	mov	exitf[bx],ax
	mov	exitf[bx+2],dx
	add	bx,4
	mov	exitc,bx
	xor	ax,ax
	pop	bp
	lret
aterr:	mov	al,1
	pop	bp
	lret

;	exit()

exit_:	pop	ax		; return addr
	pop	ax
	pop	rcode		; return code
efun:	mov	bx,exitc	; # exit functions
	or	bx,bx		; test for eol
	jz	cfile		; eol
	sub	bx,4
	mov	exitc,bx	; next element
	push	cs
	mov	ax,offset efun	; return address
	push	ax
	ljmp	dword exitf[bx]
	public	closeall_
cfile:	lcall	closeall_
	mov	ax,rcode
	jmp	DO_EXIT

;	_exit();

_exit_:	POP	AX		;RETRIEVE RETURN CODE
	POP	AX
	POP	AX
DO_EXIT:			;IN DOS 2.0 USE CODE 4C TO TERMINATE
				;AS THIS ALLOWS AN ERROR CODE
	CMP	_MSDOS2_,0	;DOS 1.0 ?
	JZ	OLDEND
	MOV	AH,TERMINATE	;DOC 2.0 TERMINATE CODE
	INT	IBM


OLDEND:	PUSH	_PCB_		;CREATE A LONG RETURN TO _PCB_:0
	MOV	AX,0
	PUSH	AX
	LRET

NOT_ENOUGH:
	MOV	AX,&NE_MSG
	PUSH	SS
	PUSH	AX
	LCALL	PUTS_
	ADD	SP,2
	MOV	AL,2		;ERROR EXIT
	JMP	DO_EXIT


;	charactor = getchar();

GETCHAR_:
	CMP	LASTCH,0	;SAVED CHAR
	JZ	DOGC
GLAST:	MOV	AL,LASTCH	;RETURN LAST CHAR
	MOV	LASTCH,0
	JMP	GOTIN
DOGC:	MOV	AH,CI_CODE	;CODE FOR ECHOED INPUT
	INT	IBM		;DO THE CONSOLE READ
GOTIN:	MOV	AH,0		;RETURN A WORD
	CMP	AL,26		;CONTROL z ?
	JZ	READNFG
	LRET			;CHARACTER IS IN AL
READNFG:MOV	AX,-1		;-1 IF EOF
	LRET


;	putchar(character);

PUTCHAR_:POP	AX		;RETURN ADDRESS
	POP	BX
	POP	DX		;DL IS CHARACTER
	PUSH	DX
	PUSH	BX
	PUSH	AX
	CMP	DL,LF		;MUST CHANGE LF TO CR,LF
	JNZ	XCO
PS_END:	MOV	DL,CR		;PRINT THE CR FIRST
	LCALL	XCO
	MOV	DL,LF		;PUT THE LF BACK
XCO:	MOV	AH,CO_CODE
	INT	IBM		;DO THE WRITE
	MOV	AH,CO_CODE
	LRET


;	puts(string address);

PUTS_:	POP	AX		;RETURN ADDRESS
	POP	CX
	POP	BX		;STRING ADDRESS
	POP	ES
	PUSH	ES
	PUSH	BX
	PUSH	CX
	PUSH	AX
PS_LP:	MOV	AL,ES:[BX]		;NEXT CHAR
	OR	AL,AL
	JZ	PS_END		;ZERO AT END OF STRING
	PUSH	ES
	PUSH	BX
	PUSH	AX		;CHAR
	LCALL	PUTCHAR_	;LET PUTCHAR TURN LF INTO CR,LF
	ADD	SP,2
	POP	BX
	POP	ES
	INC	BX		;STRING POINTER
	JMP	PS_LP





	PUBLIC	CI_, CO_, CSTS_

;	charactor = ci();

CI_:	CMP	LASTCH,0	;SAVED CHAR
	JZ	DOCI
	MOV	AL,LASTCH	;RETURN LAST CHAR
	MOV	LASTCH,0
	MOV	AH,0
	LRET
DOCI:	MOV	AH,DIRECT_INPUT	;CODE FOR DIRECT CONSOLE INPUT
	INT	IBM
	MOV	AH,0		;MAKE AN INT
	LRET


;	charactor or zero = csts();

CSTS_:	MOV	AH,DIRECT_CODE	;CODE FOR DIRECT CONSOLE IO
	MOV	DL,0FFH		;WANT A CHAR
	INT	IBM
	MOV	LASTCH,AL	;SAVE CHARACTER
	MOV	AH,0		;MAKE AN INT
	LRET


;	co(character);

CO_:	POP	AX		;RETURN ADDRESS
	POP	BX
	POP	DX
	PUSH	DX
	PUSH	BX
	PUSH	AX
	MOV	AH,DIRECT_CODE	;WANT A DIRECT CONSOLE OUTPUT
	INT	IBM
	LRET




;	MEMORY MANAGEMENT FUNCTIONS: _MEMORY, _SHOWSP, _SETSP

	PUBLIC	_SETSP_,_SHOWSP_

_SHOWSP_:
	MOV	AX,SP
	ADD	AX,4
	LRET

_SETSP_:
	POP	DX		;CHOP THE STACK - DANGEROUS OPERATION
	POP	CX
	POP	BX		;NEW SP VALUE
	CMP	BP,SP		;ANY LOCALS
	JNZ	NOC
	MOV	BP,BX		;MUST MOVE THE BP TOO
NOC:	MOV	SP,BX
	PUSH	BX
	PUSH	CX
	PUSH	DX
	LRET


;	SEGMENT REGISTER FUNCTIONS: _SHOWDS, _SHOWCS, _SETDS, _SHOWSS

	PUBLIC	_SHOWDS_,_SHOWCS_,_SETDS_,_SHOWSS_

_SHOWDS_:MOV	AX,DS		;DS VALUE
	LRET

_SHOWCS_:MOV	AX,CS		;CS VALUE
	LRET

_SHOWSS_:MOV	AX,SS		;SS VALUE
	LRET

_SETDS_:POP	DX		;RETURN VALUE
	POP	BX
	POP	DS		;NEW DS
	PUSH	DS
	PUSH	BX
	PUSH	DX
	LRET




;	OS CALL USED BY OPEN, CREAT ETC.

;	VALUE=_OS(CODE,ARGUMENT);

	PUBLIC	_OS_
_OS_:	PUSH	BP
	MOV	BP,SP
	PUSH	DS
	MOV	AH,[BP+6]	;IBM CODE
	MOV	DX,[BP+8]	;ARGUMENT POINTER
	MOV	DS,[BP+10]	;DS:DX IS POINTER
	INT	IBM
	MOV	AH,0		;MAKE RETURN AN INTEGER
	POP	DS
	POP	BP
	LRET

	endif
