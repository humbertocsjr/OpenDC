;
;  Released under the GNU GPL.  See http://www.gnu.org/licenses/gpl.txt
;
;  This program is part of the DeSmet C Compiler
;
;  DeSmet C is free software; you can redistribute it and/or modify it
;  under the terms of the GNU General Public License as published by the
;  Free Software Foundatation; either version 2 of the License, or any
;  later version.
;
;  DeSmet C is distributed in the hope that it will be useful, but WITHOUT
;  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
;  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
;  for more details.
;
;	DIS  --		DISSASSEMBLER FOR 8086 INSTRUCTIONS.
;			ES:DI IS ADDRESS OF INSTRUCTION AND NEXT ON EXIT.
;			ON RETURN, DBUFFER WILL CONTAIN A STRING
;			CONTAINING THE DISSASSEMBLED INSTRUCTION. DBUFFER
;			IS A PARANOID STRING - THE FIRST BYTE IS THE LENGTH
;			(NOT INCLUDING THE LENGTH BYTE) AND THE STRING
;			IS ALSO TERMINATED BY A ZERO.

;			ALL REGISTERS ARE CLOBBERED EXCEPT CS:IP, SS:SP,
;			AND BP. ES:DI IS AS DESCRIBED ABOVE.

;	DISSASSEMBLY RECREATES INTEL MNUMONICS EXCEPT:

;	1) RELATIVE JUMPS SHOW THE REAL ADDRESS, E.G.
;		JL	A=1234

;	2) ILLEGAL INSTRUCTIONS DISSASSEMBLE AS 'NFG'.



	PUBLIC	DBUFFER_:BYTE		;RESULT GOES HERE

;	REGISTERS IN ORDER
;	PUBLIC	REG,BREG,SEGREG

REG	DB	'AX',0,'CX',0,'DX',0,'BX',0,'SP',0,'BP',0,'SI',0,'DI',0,0
BREG	DB	'AL',0,'CL',0,'DL',0,'BL',0,'AH',0,'CH',0,'DH',0,'BH',0,0
SEGREG	DB	'ES',0,'CS',0,'SS',0,'DS',0,0

;	MEANING OF LOW 3 BITS OF AN R/M.

RM_TYPES DB	'BX+SI',0,'BX+DI',0,'BP+SI',0,'BP+DI',0
	DB	'SI',0,'DI',0,'BP',0,'BX',0

;	PREFIX CODES AND MNUMONICS

;	PUBLIC	LOCKOP,PREMNU,PREOPS
PREOPS	DB	26H,2EH,36H,3EH		; OPS FOR ES: CS: SS: AND DS:
LOCKOP	DB	0F0H,0F2H,0F3H,0F2H,0	;LOCK, REP, REPZ
PREMNU	DB	'LOCK',0,'REP',0,'REPZ',0,'REPNZ',0,0


;	NOOP IS THE CODES FOR THE INSTRUCTIONS WITH NO OPERANDS.
;	PUBLIC	NOOP,NOMNU
NOOP	DB	0FH,27H,2FH,37H,3FH,90H,98H,99H,9BH,9CH,9DH,9EH,9FH
	DB	0A4H,0A5H,0A6H,0A7H,0AAH,0ABH,0ACH,0ADH,0AEH,0AFH
	DB	0C3H,0CBH,0CEH,0CFH,0D4H,0D5H,0D6H,0D7H,0F1H,0F4H
	DB	0F5H,0F8H,0F9H,0FAH,0FBH,0FCH,0FDH,0

;	NOMNU IS THE MNUMONICS FOR ABOVE

NOMNU	DB	'NFG',0,'DAA',0,'DAS',0,'AAA',0,'AAS',0,'NOP',0,'CBW',0
	DB	'CWD',0,'WAIT',0,'PUSHF',0,'POPF',0,'SAHF',0,'LAHF',0
	DB	'MOVSB',0,'MOVSW',0,'CMPSB',0,'CMPSW',0,'STOSB',0,'STOSW',0
	DB	'LODSB',0,'LODSW',0,'SCASB',0,'SCASW',0
RETMNU	DB	'RET',0
LRETMNU	DB	'LRET',0
	DB	'INTO',0,'IRET',0,'AAM',0,'AAD',0,'NFG',0,'XLAT',0
NFGMNU	DB	'NFG',0
	DB	'HLT',0,'CMC',0,'CLC',0,'STC',0,'CLI',0,'STI',0
	DB	'CLD',0,'STD',0,0

;	CODES FOR THE POP AND PUSH SEGREG INSTRUCTIONS

;	PUBLIC	POPOP,PUSHOP,IDPPOP,IDPPMNU
POPOP	DB	7,7,17H,1FH,0		;POP CS IS ILLEGAL
PUSHOP	DB	06H,0EH,16H,1EH,0

;	CODES AND MNUMONICS FOR INC, DEC, PUSH, POP

IDPPOP	DB	40H,48H,50H,58H,0	;HIGH 5 BITS OF CODES
IDPPMNU	DB	'INC',0,'DEC',0
PUSHMNU	DB	'PUSH',0
POPMNU	DB	'POP',0,0

;	CODES AND MNUMONICS FOR THE ARITHMETIC INSTRUCTIONS

;	PUBLIC	ARITHMNU,ARITHALI
ARITHMNU DB   'ADD',0,'OR',0,'ADC',0,'SBB',0,'AND',0,'SUB',0,'XOR',0,'CMP',0,0

;	CODES FOR ARITH BYTE,IMMEDIATE

ARITHALI DB	4,0CH,14H,1CH,24H,2CH,34H,3CH,0

;	CODES FOR ARITH BYTE,IMMEDIATE

ARITHAXI DB	5,0DH,15H,1DH,25H,2DH,35H,3DH,0


;	MNUMONICS FOR THE JUMP CONDTIONAL INSTRUCTIONS

;	PUBLIC JCOND_MNU,JCONDOP
JCOND_MNU DB	'JO',0,'JNO',0,'JB',0,'JNB',0,'JZ',0,'JNZ',0,'JNA',0,'JA',0
	  DB	'JS',0,'JNS',0,'JP',0,'JNP',0,'JL',0,'JNL',0,'JNG',0,'JG',0

;	ALTERNATE FNAMES OF JUMP RELATIVES
	DB	'JNAE',0,'JAE',0,'JE',0,'JNE',0,'JBE',0,'JNBE',0,'JPE',0
	DB	'JPO',0,'JNGE',0,'JGE',0,'JLE',0,'JNLE',0

;	CODES AND MNUMONICS FOR LOOP TYPE INSTRUCTIONS
;	NOTICE MNUMONICS ARE TOGETHER

LOOPMNU	DB	'LOOPNZ',0,'LOOPZ',0,'LOOP',0,'JCXZ',0,'LOOPE',0,'LOOPNE',0,0
;	OPCODES FOR ALL THE JUMP RELATIVES

JCONDOP	DB	70H,71H,72H,73H,74H,75H,76H,77H,78H,79H,7AH,7BH,7CH,7DH,7EH,7FH
	DB	72H,73H,74H,75H,76H,77H,7AH,7BH,7CH,7DH,7EH,7FH

LOOPOP	DB	0E0H,0E1H,0E2H,0E3H,0E1H,0E0H,0


;	MNUMONICS FOR TEST AND XCHG AND MOV AND LEA AND INT AND ESC
;	AND IN AND OUT

;	PUBLIC	TESTMNU
TESTMNU	DB	'TEST',0
XCHGMNU	DB	'XCHG',0
MOVMNU	DB	'MOV',0
LEAMNU	DB	'LEA',0
INTMNU	DB	'INT',0
ESCMNU	DB	'ESC',0
INMNU	DB	'IN',0
OUTMNU	DB	'OUT',0,0

;	CODES FOR LES AND LDS

;	PUBLIC	LESOP
LESOP	DB	0C4H,0C5H,0

;	MNUMONICS FOR LES, LDS

;	PUBLIC	LESMNU,SHIFTMNU
LESMNU	DB	'LES',0,'LDS',0,0

;	MNUMONICS FOR THE SHIFT INSTRUCTIONS

SHIFTMNU DB   'ROL',0,'ROR',0,'RCL',0,'RCR',0,'SHL',0,'SHR',0,'NFG',0,'SAR',0,0

;	MNUMONICS FOR GROUP 1 AND 2

;	PUBLIC	GRP1MNU,GRP2MNU
GRP1MNU DB	'TEST',0,'NFG',0,'NOT',0,'NEG',0,'MUL',0,'IMUL',0
	DB	'DIV',0,'IDIV',0,0
GRP2MNU	DB	'INC',0,'DEC',0
CALLMNU	DB	'CALL',0
LCALLMNU DB	'LCALL',0
JMPMNU	DB	'JMP',0
LJMPMNU	DB	'LJMP',0
	DB	'PUSH',0,'NFG',0,0

BYTEPTR	DB	'BYTE PTR ',0
WORDPTR	DB	'WORD PTR ',0
ANANOMOUS DB	0			;SET TO 1 IF ANANOMOUS REFERENCE




	CSEG

	PUBLIC	DIS_

DIS_:	MOV	DH,99			;NO SEGMENT OVERRIDE
					;DH OF 0 TO 3 MEANS SEGMENT OVERRIDE
	MOV	DBUFFER_,0		;OUTPUT BUFFER EMPTY
	MOV	ANANOMOUS,0		;SET TO 1 IF 'WORD PTR' NEEDED

;	LOOK FOR SEGMENT OVERRIDES OR REP OR REPZ OR LOCK


NEXT_PRE:
	MOV	AL,ES:[DI]		;FIRST BYTE OF INSTRUCTION
	INC	DI
	MOV	DL,AL			;REMEMBER OP CODE
	MOV	SI,OFFSET PREOPS	;SEE IF A SEGMENT OVERRIDE
	CALL	FIND_OP
	JNZ	TRY_NO			;NOT A PREFIX
	CMP	BL,4			;0 TO 3 ARE SEGMENT OVERRIDES
	JNC	GOT_PRE
	MOV	DH,BL			;INDEX OF SEGMENT OVERRIDE
	JMP	NEXT_PRE		;COUND HAVE MULTIPLE PREFIXES
GOT_PRE:SUB	BL,4			;NEED INDEX OF LOCK, REP OR REPZ
	MOV	SI,OFFSET PREMNU
	CALL	ADD_INDEXED
	MOV	AL,' '			;ONE BLANK AFTER PREFIX
	CALL	ADD_CHAR
	JMP	NEXT_PRE



;	LOOK FOR AN OPERATOR WITHOUT OPERANDS

TRY_NO:	MOV	SI,OFFSET NOOP		;LIST OF BYTE CODES WITH NO OPERANDS
	CALL	FIND_OP
	JNZ	TRY_LOW
	AND	AL,0FEH			;AAM AND AAD ARE 2 BYTES
	CMP	AL,0D4H			;AAM ID 0D4H, AAM IS 0D5H
	JNZ	ONE_BYTE
	INC	DI
ONE_BYTE:
	MOV	SI,OFFSET NOMNU		;LOOK UP MNUMONIC
	JMP	ADD_INDEXED		;ADD MN TO OUTPUT

;	SEPARATE OUT THE INSTRUCTIONS LESS THAN 60H

TRY_LOW:CMP	AL,60H			;HANDLE ALL OBOVE 80H SEPARATELY
	JNB	TRY_HIGH		;MUST BE HIGH

;	LOOK FOR A PUSH SEGREG INSTRUCTION

	MOV	SI,OFFSET PUSHOP
	CALL	FIND_OP
	JNZ	TRY_POP
	PUSH	BX			;INDEX TO REGISTER
	MOV	SI,OFFSET PUSHMNU	;ADD PUSH
	CALL	ADD_STRINGP
	POP	BX
	JMP	ADD_SEGREG		;PRINT SEGREG

;	LOOK FOR A POP SEGREG INSTRUCTION

TRY_POP:MOV	SI,OFFSET POPOP
	CALL	FIND_OP
	JNZ	TRY_IDPP
	PUSH	BX			;INDEX TO REGISTER
	MOV	SI,OFFSET POPMNU	;ADD POP
	CALL	ADD_STRINGP
	POP	BX
	JMP	ADD_SEGREG		;PRINT SEGREG

;	LOOK FOR THE INC, DEC, PUSH, POP REGISTER INSTRUCTIONS

TRY_IDPP:
	AND	AL,0F8H			;KILL LOW 3 BITS
	MOV	SI,OFFSET IDPPOP	;4 OPERANDS
	CALL	FIND_OP
	MOV	AL,DL			;RESTORE CODE
	JNZ	TRY_ARITHALI
	MOV	SI,OFFSET IDPPMNU	;NAME FOR INC DEC PUSH POP
	CALL	ADD_INDEXEDP
	MOV	BL,DL			;REGISTER INDEX
	AND	BX,7			;WANT INDEX 0 TO 7
	JMP	ADD_REG			;PRINT NAME OF REGISTER



;	LOOK FOR ADD AL,IMM  OR  AL,IMM ETC.

TRY_ARITHALI:
	MOV	SI,OFFSET ARITHALI	; CHECK LIST OF 8
	CALL	FIND_OP
	JNZ	TRY_ARITHAXI
	MOV	SI,OFFSET ARITHMNU	;PRINT ARITHMETIC MN
	CALL	ADD_INDEXEDP
	MOV	SI,OFFSET BREG		;AL IS FIRST
	CALL	ADD_STRING
	JMP	ADD_COMMAIB		;PRINT ,HH AND RETURN


;	LOOK FOR ADD AX,IMM  OR  AX,IMM ETC.

TRY_ARITHAXI:
	MOV	SI,OFFSET ARITHAXI	; CHECK LIST OF 8
	CALL	FIND_OP
	JNZ	TRY_ARITHRM
	MOV	SI,OFFSET ARITHMNU	;PRINT ARITHMETIC MN
	CALL	ADD_INDEXEDP
	MOV	SI,OFFSET REG		;AX IS FIRST
	CALL	ADD_STRING
	JMP	ADD_COMMAIW		;PRINT ,HHHH AND RETURN


;	MUST BE ONE OF THE ARITHMETIC REG,RM

TRY_ARITHRM:
	SHR	AL,1			;DIVIDE BY 8 TO GET MNUMONIC
	SHR	AL,1
	SHR	AL,1
	MOV	BL,AL			;BX IN MNUMONIC INDEX
	AND	BX,7			;INDEX 0 TO 7
	MOV	SI,OFFSET ARITHMNU
	CALL	ADD_INDEXEDP
	JMP	ADD_REGRM



;	INSTRUCTIONS AT 60H OR ABOVE START HERE

TRY_HIGH:

;	GET RID OF THE 6XH ILLEGALS

	MOV	BL,AL			;CODE
	AND	BL,0F0H
	CMP	BL,60H			;ALL 60H'S ILLEGAL
	JZ	BAD_INST

;	JUMP CONDITIONALS ARE HERE

	CMP	BL,70H			;70H IS JUMP CONDITIONAL ROW
	JNZ	TRY_IMMED
	MOV	SI,OFFSET JCOND_MNU	;MNUMONIC FOR JUMP
	MOV	BL,AL			;INSTRUCTION LOW BYTES ARE INDEX
	AND	BX,0FH
	CALL	ADD_INDEXEDP
	JMP	ADD_BREL		;PRINT TARGET ADDRESS



;	IMMEDIATE CODED INSTRUCTIONS HERE

TRY_IMMED:
	CMP	AL,84H			;IF 80H TO 83H THEN IMMEDIATE
	JNC	TRY_TEST
	MOV	AL,ES:[DI]		;RM BYTE FOR IMMEDIATE
	CALL	EXTRACT			;TURN XXX INTO INDEX
	MOV	SI,OFFSET ARITHMNU	;NEED ADD, SUB ETC.
	CALL	ADD_INDEXEDP		;PRINT MNUMONIC
	MOV	ANANOMOUS,1		;NEED EXPLICIT TYPE
	CALL	ADD_RM			;PRINT THE MEMORY REFERENCE.
	TEST	DL,1			;LOOK FOR BYTE IMMEDIATE FIRST
	JZ	ADD_COMMAIB		;PRINT ,HH
	TEST	DL,2			;IS IMMEDIATE SIGN EXTENDED?
	JZ	ADD_COMMAIW		;NO
	JMP	ADD_COMMAIS		;MUST BE SIGN EXTENDED


;	TEST B OR W R/M

TRY_TEST:CMP	AL,86H			;TEST R/M IS 84H AND 85H
	JNC	TRY_XCHG
	MOV	SI,OFFSET TESTMNU	;PRINT TEST
	CALL	ADD_STRINGP
	JMP	ADD_REGRM		;PRINT THE REG, R/M.


;	XCHG B OR W R/M

TRY_XCHG:CMP	AL,88H			;XCHG IS 86H OR 87H
	JNC	TRY_MOVE
	MOV	SI,OFFSET XCHGMNU	;PRINT XCHG
	CALL	ADD_STRINGP
	JMP	ADD_REGRM		;PRINT THE REG, R/M.



;	MOV B OR W REG, R/M

TRY_MOVE:
	CMP	AL,8CH			;FROM 88H TO 8BH
	JNC	TRY_MOVSR
	MOV	SI,OFFSET MOVMNU
	CALL	ADD_STRINGP
	JMP	ADD_REGRM			;PRINT THE REG, R/M.



;	MOVE	SEGMENT REGISTER, R/M AND LEA AND POP R/M.

TRY_MOVSR:
	CMP	AL,90H			;MOV SR,RM IS 8EH, TO SR IS 8CH
	JNB	TRY_XCHGR
	TEST	AL,1			;BIT OFF FOR MOV SR
	JNZ	LEA_OR_POP

;	MOV SEGREG

	MOV	SI,OFFSET MOVMNU	;PRINT MOV
	CALL	ADD_STRINGP
	OR	DL,1			;WORD TYPE MEM REFERENCE
	TEST	DL,2			;BIT IS ON FOR 'T' BIT
	JNZ	MOV_RM_TO_SREG
	PUSH	ES:[DI]			;WILL NEED THE REGISTER BITS LATER
	CALL	ADD_RM			;PRINT R/M OPERAND
	CALL	ADD_COMMA		;ADD A COMMA
	POP	AX			;HAS THE REG BITS
	CALL	EXTRACT			;FIGURE OUT REGISTER
	JMP	ADD_SEGREG		;PRINT SEGMENT REGISTER

MOV_RM_TO_SREG:
	MOV	AL,ES:[DI]		;FIRST R/M BYTE HAS ENCODED REG
	CALL	EXTRACT			;FIND OUT EHICH REG
	CALL	ADD_SEGREG		;ADD THE SEGMENT REGISTER
	CALL	ADD_COMMA		;ADD A COMMA
	JMP	ADD_RM			;ADD THE R/M


;	LEA OR POP R/M INSTRUCTION

LEA_OR_POP:
	TEST	AL,2			;BIT ON FOR POP R/M
	JNZ	POP_RM
	MOV	SI,OFFSET LEAMNU	;ADD POP
	CALL	ADD_STRINGP
	JMP	ADD_RM_TO_REG



POP_RM:	MOV	SI,OFFSET POPMNU	;ADD POP
	CALL	ADD_STRINGP
	JMP	ADD_RM			;RINT THE R/M



;	XCHG	AX,REG

TRY_XCHGR:
	CMP	AL,98H			;XCHG IN 90H TO 97H RANGE
	JNC	TRY_CALLL
	MOV	SI,OFFSET XCHGMNU	;ADD XCHG
	CALL	ADD_STRINGP
	MOV	BX,0			;PRINT AX
	CALL	ADD_REG
	CALL	ADD_COMMA
	MOV	BL,DL			;PRINT WORD REGISTER
	AND	BX,7
	JMP	ADD_REG


;	LONG CALL AND LONG JUMP

TRY_CALLL:
	CMP	AL,09AH			;LONG JUMP
	JZ	LONG_CALL
	CMP	AL,0EAH			;LONG JUMP
	JNZ	TRY_MOVAX

;	LONG JUMP

	MOV	SI,OFFSET LJMPMNU	;ADD JUMP
	CALL	ADD_STRINGP
	JMP	LONG_ADDR

;	LONG CALL

LONG_CALL:
	MOV	SI,OFFSET LCALLMNU
	CALL	ADD_STRINGP
LONG_ADDR:
	MOV	AX,ES:[DI+2]
	CALL	ADD_HEXW		;PRINT SEGMENT FOR LONG ADDRESS
	MOV	AL,':'			;ADD A COLON
	CALL	ADD_CHAR
	MOV	AX,ES:[DI]		;ADD OFFSET FOR LONG ADDRESS
	ADD	DI,4			;ADJUST DI FOR 4 BYTE ADDR
	JMP	ADD_HEXW


;	MOVE FROM MEMORY FROM OR TO AX OR AL

TRY_MOVAX:
	CMP	AL,0A4H			;A0H TO A3H
	JNC	TRY_TESTI
	MOV	SI,OFFSET MOVMNU	;ADD MOV
	CALL	ADD_STRINGP
	TEST	DL,2			;ON IF TO MEMORY
	JNZ	AX_TO_MEM
	XOR	AL,AL			;INDEX 0 FOR AX OR AL
	CALL	ADD_ANY_REG		;PRINT AX OR AL
	CALL	ADD_COMMA
	JMP	RM_FOR_AX		;ADD WORD ADDRESS

AX_TO_MEM:
	CALL	RM_FOR_AX		;PRINT MEMORY LOCATION
	CALL	ADD_COMMA
	XOR	AL,AL			;INDEX 0 FOR AX OR AL
	JMP	ADD_ANY_REG		;PRINT AX OR AL

RM_FOR_AX:
	CMP	DH,99			;IS THERE A SEGMENT OVERRIDE?
	JZ	RMXNO
	MOV	BL,DH			;NEED SEGREG INDEX
	MOV	BH,0
	CALL	ADD_SEGREG		;PRINT A SEGMENT REGISTER
	MOV	AL,':'			;FOLLOWED BY COLON
	CALL	ADD_CHAR
RMXNO:	JMP	RM_IS_DIRECT



;	TEST AL OR AX IMMEDIATE

TRY_TESTI:CMP	AL,0AAH			;TEST IMMEDIATE IS A8H AND A9H
	JNC	TEST_ITOREG
	MOV	SI,OFFSET TESTMNU	;ADD TEST
	CALL	ADD_STRINGP
	XOR	AL,AL			;ADD AL OR AX
	CALL	ADD_ANY_REG
	TEST	DL,1			;ONE ON IF WORD IMMEDIATE
	JNZ	ADD_COMMAIW
	JMP	ADD_COMMAIB



;	MOVE IMMEDIATE TO BYTE OR WORD REGISTER

TEST_ITOREG:
	CMP	AL,0C0H			;B0H TO BFH ARE IMM TO REG
	JNC	TRY_ALLC0
	MOV	SI,OFFSET MOVMNU	;ADD MOV
	CALL	ADD_STRINGP
	MOV	AL,DL			;REGISTER INDEX
	SHR	DL,1			;PUT B OR W BIT INTO BIT 0
	SHR	DL,1
	SHR	DL,1
	CALL	ADD_ANY_REG		;PRINT REGISTER
	TEST	DL,1			;SEE IF BYTE OR WORD IMM
	JNZ	ADD_COMMAIW
	JMP	ADD_COMMAIB


;	EVERYTHING IN THE 0C0H ROW

TRY_ALLC0:
	CMP	AL,0D0H			;ABOVE 0C0H?
	JNC	TRY_SHIFT
	CMP	AL,0C2H			;RET N ?
	JZ	RETN
	CMP	AL,0CAH			;LRET N ?
	JNZ	TRY_LES

;	LRET N

	MOV	SI,OFFSET LRETMNU
	CALL	ADD_STRINGP		;ADD LRET
	JMP	ADD_IW			;PRINT WORD TO ADD TO SP


;	RET N

RETN:	MOV	SI,OFFSET RETMNU
	CALL	ADD_STRINGP		;ADD RET
	JMP	ADD_IW			;PRINT NUM TO ADD TO SP


;	LES AND LDS

TRY_LES:MOV	SI,OFFSET LESOP
	CALL	FIND_OP
	JNZ	TRY_MOVI_RM
	MOV	SI,OFFSET LESMNU	;ADD LES OR LDS
	CALL	ADD_INDEXEDP
	OR	DL,3			;SET DIR FLAG SO R/M TO REG, ALSE W.
	JMP	ADD_REGRM


;	MOVE IMMEDIATE TO R/M

TRY_MOVI_RM:
	CMP	AL,0C8H
	JNC	TRY_INT
	MOV	SI,OFFSET MOVMNU	;ADD MOV
	CALL	ADD_STRINGP
	CALL	ADD_RM			;PRINT REG OR MEMORY REFERENCE
	TEST	DL,1
	JNZ	ADD_COMMAIW		;ADD ,HHHH
	JMP	ADD_COMMAIB		;ADD ,HH



;	VARIOUS INTERRUPTS.

TRY_INT:CMP	AL,0CCH			;FIRST INT
	JC	BAD_INST		;GOT A NFG
	MOV	SI,OFFSET INTMNU	;ADD INT
	CALL	ADD_STRINGP
	CMP	DL,0CCH			;GOOD OLD INT3
	JNZ	ADD_IB			;PRINT INT NUMBER
	MOV	AL,'3'			;GOT A SINGLE BYTE INTERRUPT 3
	JMP	ADD_CHAR



;	SHIFT ENCODED INSTRUCTIONS

TRY_SHIFT:
	CMP	AL,0D4H			;SHIFT IS D0H TO D3H
	JNC	TRY_ESC
	MOV	AL,ES:[DI]		;GET XXX OUT OF INSTRUCTION
	CALL	EXTRACT
	MOV	SI,OFFSET SHIFTMNU	;ADD SHIFT MNUMONIC
	CALL	ADD_INDEXEDP
	MOV	ANANOMOUS,1		;NEED EXPLICIT TYPE
	CALL	ADD_RM			;PRINT THE R/M FOR SHIFT
	CALL	ADD_COMMA
	TEST	DL,2			;VARIABLE TYPE SHIFT
	JNZ	SHIFT_V
	MOV	AL,'1'			;SHIFT BY 1
	JMP	ADD_CHAR
SHIFT_V:MOV	BX,1			;PRINT CL
	JMP	ADD_BREG


;	ESCAPE INSTRUCTIONS

TRY_ESC:CMP	AL,0E0H			;ESCAPE IS D8H TO DFH
	JNC	TRY_LOOP
	MOV	SI,OFFSET ESCMNU	;ADD ESC
	CALL	ADD_STRINGP
	MOV	AH,DL			;EXTRACT 6 BITS FOR ESC
	MOV	AL,ES:[DI]		;HAS LOW 3 BITS IN XXX
	SHL	AL,1
	SHL	AL,1
	SHL	AX,1
	SHL	AX,1
	SHL	AX,1
	MOV	AL,AH			;HAS 6 BITS
	AND	AL,111111B		;ISOLATE THE ESCAPE 6
	CALL	ADD_HEXB		;AND ADD
	CALL	ADD_COMMA
	JMP	ADD_RM			;PRINT R/M FROM ESCAPE


TRY_LOOP:
	MOV	SI,OFFSET LOOPOP	;LOOK FOR LOOPS
	CALL	FIND_OP
	JNZ	TRY_IO
	MOV	SI,OFFSET LOOPMNU	;ADD LOOP MNUMONIC
	CALL	ADD_INDEXEDP
	JMP	ADD_BREL


;	I/O INSTRUCTIONS

TRY_IO:	MOV	BL,AL			;LOOK FOR ALL I/O
	AND	BL,11110100B		;IO AT E4H TO E7H AND ECH TO EFH
	CMP	BL,0E4H
	JNZ	TRY_JUMP
	TEST	DL,2			;BIT ON IF OUT
	JNZ	IS_OUT
	MOV	SI,OFFSET INMNU
	CALL	ADD_STRINGP		;ADD IN
	MOV	AL,0			;PRINT AL OR AX
	CALL	ADD_ANY_REG
	CALL	ADD_COMMA
	TEST	DL,8			;VARIABLE ?
	JZ	FIXED_IO
	MOV	BX,2			;ADD DX
	JMP	ADD_REG
FIXED_IO:
	JMP	ADD_IB			;PRINT PORT NUMBER

IS_OUT:	MOV	SI,OFFSET OUTMNU
	CALL	ADD_STRINGP		;ADD IN OR OUT
	TEST	DL,8			;VARIABLE ?
	JZ	FIX_IO
	MOV	BX,2			;ADD DX
	CALL	ADD_REG
	JMP	COMMAX
FIX_IO:
	CALL	ADD_IB			;PRINT PORT NUMBER
COMMAX:
	CALL	ADD_COMMA
	MOV	AL,0			;PRINT AL OR AX
	JMP	ADD_ANY_REG




;	JUMP AND CALL

TRY_JUMP:
	CMP	AL,0ECH			;CALL D IS E8H, JMP D  E9H, JMP S EBH
	JNC	TRY_GRP1
	CMP	AL,0E8H			;CALL SHORT DIRECT
	JNZ	IS_JMP
	MOV	SI,OFFSET CALLMNU
	CALL	ADD_STRINGP
	JMP	ADD_WREL		;ADD WORD RELATIVE ADDRESS

IS_JMP:	MOV	SI,OFFSET JMPMNU	;ADD JMP
	CALL	ADD_STRINGP
	CMP	DL,0EBH			;EBH IS BYTE RELATIVE JUMP
	JZ	ADD_BREL
	JMP	ADD_WREL


;	GROUP1 INSTRUCTIONS

TRY_GRP1:
	CMP	AL,0F8H			;GROUP1 IS F6H AND F7H
	JNC	IS_GRP2
	MOV	AL,ES:[DI]		;GET XXX BITS
	CALL	EXTRACT			;GET XXX BITS INTO BX
	PUSH	BX			;NEED XXX LATER TO TEST FOR TEST
	MOV	SI,OFFSET GRP1MNU	;ADD MNUMONIC
	CALL	ADD_INDEXEDP
	MOV	ANANOMOUS,1		;NEED EXPLICIT TYPE
	CALL	ADD_RM			;PRINT THE R/M
	POP	BX			;XXX BITS
	CMP	BL,0			;TEST HAS AN XXX OF ZERO
	JNZ	GRP1_RET
	TEST	DL,1			;IMMEDIATE BYTE OR WORD ?
	JNZ	ADD_COMMAIW		;IMMEDIATE WORD
	JMP	ADD_COMMAIB		;IMMEDIATE BYTE
GRP1_RET:
	RET


;	GROUP2 INSTRUCTIONS

IS_GRP2:MOV	AL,ES:[DI]		;GET XXX BITS
	TEST	AL,110000B		;INC AND DEC ARE ANANOMOUS
	JNZ	NOTYP
	MOV	ANANOMOUS,1		;NEED EXPLICIT TYPE
NOTYP:	CALL	EXTRACT			;GET XXX BITS INTO BX
	MOV	SI,OFFSET GRP2MNU
	CALL	ADD_INDEXEDP		;ADD MNUMONIC
	JMP	ADD_RM			;PRINT THE R/M



	
BAD_INST:
	MOV	SI,OFFSET NFGMNU	;ADD NFG (FRIGGING)
	JMP	ADD_STRING




;	UTILITY ROUTINES FOR DISSASSEMBLER

;	FIND_OP  --	MATCH AL TO LIST OF BYTES AT SI. RETURN Z FLAG AND
;			BX=OFFSET FROM START IF FOUND OR NZ FLAG IF FAIL.
;			LIST ENDS WITH A ZERO.

FIND_OP:XOR	BX,BX			;INDEX FOR FIND
NEXT_OP:CMP	AL,DS:[SI+BX]		;MATCH ?
	JZ	FIND_RET		;YES
	INC	BX
	CMP	DS:BYTE [SI+BX],0	;AT END ?
	JNZ	NEXT_OP
	INC	BX			;SET NOT ZERO FLAG
FIND_RET:
	RET


;	THE ADD ROUTINED ADD VARIOUS THINGS TO DBUFFER_. AL, BX AND SI ARE
;	CLOBBERED BUT OTHER REGISTERS ARE PRESERVED.



;	ADD_REGRM  --	DL HAS A BIT FOR BYTE OR WORD AND A BIT FOR
;			DIRECTION. ES:DI ADDRESSES THE R/M. PRINT OPERAMDS
;			AND ADJUST DI.

ADD_REGRM:
	TEST	DL,2			;BIT IS ON FOR 'T' BIT
	JNZ	ADD_RM_TO_REG
ADD_RM_FROM_REG:			;FROM REG TO R/M
	PUSH	ES:[DI]			;WILL NEED THE REGISTER BITS LATER
	CALL	ADD_RM			;PRINT R/M OPERAND
	CALL	ADD_COMMA		;ADD A COMMA
	POP	AX			;HAS THE REG BITS
	CALL	EXTRACT			;FIGURE OUT REGISTER
	MOV	AL,BL			;REG INDEX
	JMP	ADD_ANY_REG		;PRINT REGISTER

ADD_RM_TO_REG:
	MOV	AL,ES:[DI]		;FIRST R/M BYTE HAS ENCODED REG
	CALL	EXTRACT			;FIND OUT WHICH REG
	MOV	AL,BL			;REGISTER INDEX
	CALL	ADD_ANY_REG		;ADD THE REGISTER
	CALL	ADD_COMMA		;ADD A COMMA
					;FALL INTO CODE TO PRINT R/M


;	ADD_RM  --	ES:DI POINTS TO R/M. ADD THE MEMORY REFERENCE OR
;			REGISTER. LOW BIT OF DL SAYS IF BYTE OR WORD.

ADD_RM:	CMP	DH,99			;IS THERE A SEGMENT OVERRIDE?
	JZ	END_OVER
	MOV	BL,DH			;NEED SEGREG INDEX
	MOV	BH,0
	CALL	ADD_SEGREG		;PRINT A SEGMENT REGISTER
	MOV	AL,':'			;FOLLOWED BY COLON
	CALL	ADD_CHAR
END_OVER:
	MOV	AL,ES:[DI]		;BYTE OF R/M
	INC	DI			;POINT TO NEXT BYTE IF ANY
	AND	AL,11000111B		;IGNORE XXX
	CMP	AL,00000110B		;DIRECT MEMORY REFERENCE ?
	JZ	RM_IS_DIRECT
	CMP	AL,11000000B		;IS IT REG ?
	JAE	ADD_ANY_REG		;YES.
	PUSH	AX			;DEAL WITH MOD LATER
	CMP	ANANOMOUS,1		;NEED BYTE PTR OR WORD PTR ?
	JNZ	NOPTR
	MOV	SI,OFFSET BYTEPTR	;ASSUME BYTE PTR
	TEST	DL,1			;ON IF A WORD
	JZ	OPTR
	MOV	SI,OFFSET WORDPTR
OPTR:	CALL	ADD_STRING		;ADD BYTE OR WORD PTR
NOPTR:
	POP	SI
	PUSH	SI
	AND	SI,111B			;ONLY 3 BITS
	MOV	AL,'['			;PRINT LEADING BRACKET
	CALL	ADD_CHAR
	MOV	BX,OFFSET RM_TYPES	;PRINT BX+SI OR WHATEVER
	XCHG	BX,SI			;LIST IN SI, INDEX IN BX
	CALL	ADD_INDEXED
	POP	AX			;NOW ADD IN MODE
	AND	AL,11000000B		;MODE IS TOP 2 BITS
	JZ	GOT_RM			;MODE 0 MEANS NO OFFSET
	PUSH	AX
	MOV	AL,'+'			;NEED PLUS FOR OFFSET
	CALL	ADD_CHAR
	POP	AX
	CMP	AL,01000000B		;MODE OF 1?
	JNZ	IS_MODE2
	MOV	AL,ES:[DI]		;SIGN EXTENDED BYTE OFFSET
	INC	DI
	CBW
	JMP	RM_OFF

RM_IS_DIRECT:				;DIRECT MEMORY REFERENCE
	CMP	ANANOMOUS,1		;NEED BYTE PTR OR WORD PTR ?
	JNZ	NOPPTR
	MOV	SI,OFFSET BYTEPTR	;ASSUME BYTE PTR
	TEST	DL,1			;ON IF A WORD
	JZ	OPPTR
	MOV	SI,OFFSET WORDPTR
OPPTR:	CALL	ADD_STRING		;ADD BYTE OR WORD PTR
NOPPTR:
	MOV	AL,'['			;PRINT LEADING BRACKET
	CALL	ADD_CHAR
IS_MODE2:
	MOV	AX,ES:[DI]		;WORD OFFSET
	ADD	DI,2
RM_OFF:	CALL	ADD_HEXW		;ADD THE WORD OFFSET
GOT_RM:	MOV	AL,']'			;PRINT TRAILING BRACKET
	CALL	ADD_CHAR
	RET




;	EXTRACT  --		EXTRACT XXX BITS FROM R/M IN AL AND PUT INTO
;				BX AS AN INDEX.


EXTRACT:
	SHR	AL,1			;DIVIDE BY 8 TO TURN XXX INTO INDEX
	SHR	AL,1
	SHR	AL,1			;NOW DIVIDED.
	MOV	BL,AL			;MAKE INTO A BX INDEX
	AND	BX,7			;MUST BE 0 TO 7
	RET



;	ADD_ANY_REG  --		AL IS AN INDEX TO A BYTE OR WORD REGISTER.

ADD_ANY_REG:
	MOV	BL,AL			;PUT INTO INDEX REGOSTER
	AND	BX,7			;MAKE SURE 0 TO 7
	TEST	DL,1			;BIT ON IF WORD
	JZ	ADD_BREG		;BYTE TYPE
					;FALL INTO ADD_REG




;	ADD_REG  --	ADD THE NAME OF THE WORD REGISTER INDEXED BY BX
;			TO DBUFFER_.

ADD_REG:MOV	SI,OFFSET REG
	JMP	ADD_INDEXED		;LET ADD_INDEXED DO THE WORK




;	ADD_BREG  --	ADD THE NAME OF THE BYTE REGISTER INDEXED BY BX
;			TO DBUFFER_.

ADD_BREG:
	MOV	SI,OFFSET BREG
	JMP	ADD_INDEXED		;LET ADD_INDEXED DO THE WORK



;	ADD_SEGREG  --	ADD THE NAME OF THE SEGMENT  REGISTER INDEXED BY BX
;			TO DBUFFER_.

ADD_SEGREG:
	MOV	SI,OFFSET SEGREG
	JMP	ADD_INDEXED		;LET ADD_INDEXED DO THE WORK




;	ADD_INDEXEDP  --	SAME AS ADD_INDEXED EXCEPT THAT STRING
;				IS MNUMONIC WITH OPERANDS AND BLANKS
;				MUST BE WRITTEN AFTER THE STRING.

ADD_INDEXEDP:
	CALL	ADD_INDEXED		;PRINT THE STRING
	JMP	PAD_OUT			;ADD EXTRA BLANKS



;	ADD_INDEXED  --		SI IS A LIST OF STRINGS, BX IS AN INDEX.
;				ADD THE INDEXED STRING TO DBUFFER_

ADD_INDEXED:
	OR	BX,BX			;WHEN ZERO INDEX, ADD STRING
	JZ	ADD_STRING
NEXT_IN:MOV	AL,DS:[SI]		;NEXT BYTE OF LIST
	INC	SI
	OR	AL,AL			;IF NOT ZERO, JUST GET NEXT BYTE
	JNZ	NEXT_IN
	DEC	BX			;END OF ANOTHER STRING
	JMP	ADD_INDEXED



;	ADD_STRINGP  --		ADD STRING AT SI TO BUFFER AND THEN ADD
;				BLANKS AFTER THE MNUMONIC.

ADD_STRINGP:
	CALL	ADD_STRING
PAD_OUT:MOV	AL,' '			;PRINT SOME BLANKS
	CALL	ADD_CHAR
	CMP	DBUFFER_,7		;WANT TOTAL OF 7 CHARS
	JB	PAD_OUT
	RET



;	ADD_STRING  --		ADD THE STRING AT SI TO DBUFFER_

ADD_STRING:
	MOV	AL,DS:[SI]		;NEXT BYTE OF STRING
	OR	AL,AL			;AT END ?
	JZ	END_ADDS
	CALL	ADD_CHAR		;ADD THE CHARACTER
	INC	SI
	JMP	ADD_STRING
END_ADDS:
	RET



;	ADD_COMMAIB  --		ADD ',HH' WHERE H IS AT ES:DI. INC DI.

ADD_COMMAIB:
	CALL	ADD_COMMA		;PRINT THE COMMA
ADD_IB:	MOV	AL,ES:[DI]		;NEXT BYTE OF INSTRUCTION
	INC	DI
	CALL	ADD_HEXB		;ADD THE BYTE
	RET





;	ADD_COMMAIS  --		ADD ',HHHH' WHERE H IS SIGNED BYTE AT ES:DI.
;				 INC DI.

ADD_COMMAIS:
	CALL	ADD_COMMA		;PRINT THE COMMA
	MOV	AL,ES:[DI]		;NEXT BYTE OF INSTRUCTION
	CBW				;TURN INTO AN INT
	INC	DI
	CALL	ADD_HEXW		;ADD THE WORD
	RET





;	ADD_COMMAIW  --		ADD ',HHHH' WHERE H IS AT ES:DI. ADD 2 TO DI.

ADD_COMMAIW:
	CALL	ADD_COMMA		;PRINT THE COMMA
ADD_IW: MOV	AX,ES:[DI]		;NEXT BYTE OF INSTRUCTION
	ADD	DI,2
	CALL	ADD_HEXW		;ADD THE BYTE
	RET





;	ADD_BREL  --		ADD A BYTE RELATIVE ADDRESS. ADJUST DI

ADD_BREL:
	MOV	AL,ES:[DI]		;BYTE OF OFFSET
	INC	DI
	CBW
	JMP	ADD_ADDR



;	ADD_WREL  --		ADD A WORD RELATIVE ADDRESS. ADJUST DI.

ADD_WREL:
	MOV	AX,ES:[DI]		;WORD OF OFFSET
	ADD	DI,2			;NEW IP
ADD_ADDR:
	ADD	AX,DI			;CALC ABSOLUTE ADDRESS
	PUSH	AX			;SAVE REAL ADDRESS
	MOV	AL,'A'			;PRINT 'A='
	CALL	ADD_CHAR
	MOV	AL,'='
	CALL	ADD_CHAR
	POP	AX			;ABSOLUTE ADDRESS
	CALL	ADD_HEXW
	RET




;	ADD_HEXW  --	ADD AX IN HEX TO DBUFFER_.

ADD_HEXW:
	XCHG	AL,AH			;ADD AH FIRST
	CALL	ADD_HEXB		;ADD AH
	MOV	AL,AH			;ADD AL NEXT
					;FALL INTO ADD_HEXB


;	ADD_HEXB  --	ADD AL IN HEX TO DBUFFER_.

ADD_HEXB:
	PUSH	AX			;SAVE FOR LOW NIBBLE
	SHR	AL,1			;SHIFT HI NIBBE DOWN
	SHR	AL,1
	SHR	AL,1
	SHR	AL,1
	CALL	ADD_NIB			;PRINT HIGH NIBBLE
	POP	AX			;NOW PRINT LOW NIBBLE
	AND	AL,15			;ISOLATE LOW 4 BITS
					;FALL INTO OUT_NIB
ADD_NIB:ADD	AL,'0'			;ASSUME IT IS A DIGIT
	CMP	AL,'9'			;IF NOT, ADD 7 TO MAKE A LETTER
	JBE	GOT_ADIG
	ADD	AL,7
GOT_ADIG:
	CALL	ADD_CHAR		;PRINT LOW NIBBLE
	RET







;	ADD_COMMA  --		ADD A COMMA TO SEPERATE OPERANDS

ADD_COMMA:
	MOV	AL,','			;JUST FALL INTO ADD_CHAR




;	ADD_CHAR  --		ADD A CHARACTER TO DBUFFER_ IF SPACE ALLOWS

ADD_CHAR:
	MOV	BL,DBUFFER_
	CMP	BL,30			;30 CHARS ONLY IN DBUFFER_
	JZ	ADD_END			;JUST DONT ADD
	INC	DBUFFER_			;ADD TO STRING LENGTH
	INC	BL
	MOV	BH,0			;MAKE THE LENGTH AN INDEX
	MOV	DBUFFER_[BX],AL
ADD_END:RET
	END
